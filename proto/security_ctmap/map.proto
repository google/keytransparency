// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
syntax = "proto3";

package security_ctmap;

import "github.com/gdbelvin/e2e-key-server/proto/security_protobuf/timestamp.proto";

// EpochHead is the head node of the Merkle Tree as well as additional metadata
// for the tree.
message EpochHead {
  // Realm is the domain...
  string realm = 1;
  // Epoch number
  int64 epoch = 2;
  // Root is the value of the root node of the merkle tree.
  bytes root = 3;
  // IssueTime is the time when this epoch was released. All epochs for the
  // same keyserver MUST have non-decreasing IssueTimes.
  security.protobuf.Timestamp issue_time = 4;
  // Hash of previous SEH. SHA512_256.
  bytes previous_hash = 5;
}

// Step is a combined, ordered list of SignedEntryUpdates and SignedEpochHeads
// which are made available to verifiers.
message Step {
  oneof type {
    // entry_changed contains a serialized SignedEntryUpdate.
    bytes entry_changed = 1;
    SignedEpochHead signed_epoch_head = 2;
  }
  // epoch of this udpate.
  int64 epoch = 3;
  // commitment_timestamp is the ordered commitment_timestamp of this step.
  int64 commitment_timestamp = 4;
}

// Entry is the leaf node object for the Merkle Tree. Its unique index in the
// tree is identified by a hash of an verifiable unpredictable function on the
// user_id.
message Entry {
  // Index is the location in the merkle tree for this entry.
  // If signing keys are not unique per user, we need to tie updates to a
  // particular profile.
  bytes index = 1;
  // UpdateCount prevents replaying old signed EntryUpdates.
  // not nessesarilly incremented by only one each update.
  uint64 update_count = 2;
  // EntryKey allows verifiers to validate updates to Entry.
  repeated PublicKey entry_key = 3;
  // profile_commitment is a cryptographic commitment to the Profile of the form
  // HMAC(profile_commitment_key, serialized_profile)
  bytes profile_commitment = 4;
  // Update policy: new Entry must be signed by at least one key from entry_key
  // in previous epoch.
}

// PublicKey defines a key this domain uses to sign EpochHeads with.
message PublicKey {
  // KeyFormats from Keyczar.
  oneof key_type {
    bytes ed25519 = 1; // 32 bytes (<http://ed25519.cr.yp.to/>)
    bytes rsa_verifying_sha256_2048 = 2;
    bytes ecdsa_verifying_p256 = 3;
  }
}


// SignedEpochHead represents a signed state of the Merkel tree.
message SignedEpochHead {
  // Serialized EpochHead.
  bytes epoch_head = 1;
  // Signature of head, using the signature type of the key.
  // keyed by the first 64 bits bytes of the hash of the key.
  map<fixed64, bytes> signatures = 2;
}

// SignedEntryUpdate is what users provide to update their profiles.
// A serialized SignedEntryUpdate is used as the leaf value in the MerkleTree.
message SignedEntryUpdate {
  // NewEntry is the serialized protobuf Entry.
  bytes new_entry = 1;
  // Signature of entry, by the entry_key inside entry AND the old key from the
  // previous epoch. The first proves ownership of new epoch key, and the
  // second proves the the correct owner is making this change.
  map<fixed64, bytes> signatures = 2;
}

